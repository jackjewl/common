import os
from pathlib import Path
import toml
from dataclasses import dataclass, field
from typing import Any, Dict, List
from tkinter import Tk, filedialog


# --- 辅助函数：类型推断 ---
def _infer_type(value: Any) -> str:
    if isinstance(value, str):
        return "str"
    if isinstance(value, bool):
        return "bool"
    if isinstance(value, int):
        return "int"
    if isinstance(value, float):
        return "float"
    if isinstance(value, list):
        if not value:
            return "List[Any]"
        sub_types = {_infer_type(item) for item in value if not isinstance(item, (list, dict))}
        return f"List[{sub_types.pop()}]" if len(sub_types) == 1 else "List[Any]"
    return "Any"


# --- 生成配置类 ---
def generate_config_code(config_data: dict, output_path: Path, output_file: str) -> None:
    code = [
        "# generated by toml_config.py - DO NOT EDIT MANUALLY",
        "from dataclasses import dataclass, field",
        "from typing import Any, List",
        "import toml\n"
    ]

    generated_classes: List[str] = []

    def generate_class(name: str, data: Dict[str, Any]) -> str:
        """递归生成 dataclass 代码，并返回类名"""
        class_name = f"{name.capitalize()}Config"
        class_lines = [f"@dataclass", f"class {class_name}:"]

        for key, value in data.items():
            if isinstance(value, dict):
                sub_class_name = generate_class(key, value)
                class_lines.append(f"    {key}: {sub_class_name} = field(default_factory={sub_class_name})")
            else:
                inferred_type = _infer_type(value)
                class_lines.append(f"    {key}: {inferred_type} = {repr(value)}")

        # 没有属性时防止空类报错
        if len(class_lines) == 2:
            class_lines.append("    pass")

        generated_classes.append("\n".join(class_lines))
        return class_name

    top_class_name = generate_class("Global", config_data)

    # 注意：反转输出，让子类在前，父类在后（避免引用未定义）
    code.extend(reversed(generated_classes))

    # 添加 Config 封装类，能正确实例化嵌套结构
    code.append(f"""
@dataclass
class Config:
    @staticmethod
    def from_toml(file_path: str) -> '{top_class_name}':
        def _dict_to_dataclass(cls, data: dict):
            kwargs = {{}}
            for key, value in data.items():
                if isinstance(value, dict) and hasattr(cls, key):
                    sub_cls = getattr(cls, key).__class__
                    kwargs[key] = _dict_to_dataclass(sub_cls, value)
                elif isinstance(value, list):
                    # 处理列表中的嵌套字典
                    kwargs[key] = [
                        _dict_to_dataclass(getattr(cls, key).__class__, item)
                        if isinstance(item, dict) else item
                        for item in value
                    ]
                else:
                    kwargs[key] = value
            return cls(**kwargs)

        with open(file_path, 'r', encoding='utf-8') as f:
            data = toml.load(f)
        return _dict_to_dataclass({top_class_name}, data)
    """)

    # 写入文件
    output_file_path = output_path / output_file
    with open(output_file_path, 'w', encoding='utf-8') as f:
        f.write("\n\n".join(code))
    print(f"✅ 配置类已生成到: {output_file_path}")


# --- 文件选择和生成逻辑 ---
def watch_toml_file():
    root = Tk()
    root.withdraw()

    toml_file = filedialog.askopenfilename(
        title="选择要监控的 TOML 文件",
        filetypes=[("TOML 文件", "*.toml")]
    )
    if not toml_file:
        print("⚠️ 未选择 TOML 文件，退出程序。")
        return

    output_dir = filedialog.askdirectory(title="选择输出目录")
    if not output_dir:
        print("⚠️ 未选择输出目录，退出程序。")
        return

    output_file = filedialog.asksaveasfilename(
        title="选择输出文件名",
        defaultextension=".py",
        filetypes=[("Python 文件", "*.py")]
    )
    if not output_file:
        print("⚠️ 未选择输出文件名，退出程序。")
        return

    toml_file = Path(toml_file)
    output_dir = Path(output_dir)
    output_file = Path(output_file).name

    if toml_file.exists():
        with open(toml_file, 'r', encoding='utf-8') as f:
            config_data = toml.load(f)
        generate_config_code(config_data, output_dir, output_file)
    else:
        print("⚠️ TOML 文件不存在，无法生成配置类。")


if __name__ == "__main__":
    watch_toml_file()
