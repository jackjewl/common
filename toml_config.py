import os
from pathlib import Path
import toml
from dataclasses import dataclass, field
from typing import Any, Dict, List
from tkinter import Tk, filedialog


# --- 辅助函数：类型推断 ---
def _infer_type(value: Any) -> str:
    if isinstance(value, str):
        return "str"
    if isinstance(value, bool):
        return "bool"
    if isinstance(value, int):
        return "int"
    if isinstance(value, float):
        return "float"
    if isinstance(value, list):
        if not value:
            return "List[Any]"
        sub_types = {_infer_type(item) for item in value if not isinstance(item, (list, dict))}
        return f"List[{sub_types.pop()}]" if len(sub_types) == 1 else "List[Any]"
    return "Any"


# --- 生成配置类 ---
def generate_config_code(config_data: dict, output_path: Path, output_file: str) -> None:
    code = [
        "# generated by config_watcher.py - DO NOT EDIT MANUALLY",
        "from dataclasses import dataclass, field",
        "from typing import Any, List",
        "import toml\n"
    ]

    nested_classes = []

    def generate_class(name: str, data: Dict[str, Any]):
        class_name = f"{name.capitalize()}Config"
        class_body = [f"@dataclass", f"class {class_name}:"]
        for key, value in data.items():
            if isinstance(value, dict):
                sub_class_name = generate_class(key, value)
                class_body.append(f"    {key}: '{sub_class_name}' = field(default_factory={sub_class_name})")
            else:
                inferred_type = _infer_type(value)
                class_body.append(f"    {key}: {inferred_type} = {repr(value)}")
        nested_classes.extend(class_body)
        nested_classes.append("\n")
        return class_name

    top_class_name = generate_class("Global", config_data)
    code.extend(nested_classes)

    # 添加 from_toml 方法
    code.append(f"""
@dataclass
class Config:
    @staticmethod
    def from_toml(file_path: str) -> '{top_class_name}':
        with open(file_path, 'r', encoding='utf-8') as f:
            data = toml.load(f)
        return {top_class_name}(**data)
    """)

    with open(output_path / output_file, 'w', encoding='utf-8') as f:
        f.write("\n".join(code))
    print(f"✅ 配置类已生成到: {output_path / output_file}")


# --- 文件监控逻辑 ---
def watch_toml_file():
    root = Tk()
    root.withdraw()

    toml_file = filedialog.askopenfilename(title="选择要监控的 TOML 文件", filetypes=[("TOML 文件", "*.toml")])
    if not toml_file:
        print("⚠️ 未选择 TOML 文件，退出程序。")
        return

    output_dir = filedialog.askdirectory(title="选择输出目录")
    if not output_dir:
        print("⚠️ 未选择输出目录，退出程序。")
        return

    output_file = filedialog.asksaveasfilename(title="选择输出文件名", defaultextension=".py", filetypes=[("Python 文件", "*.py")])
    if not output_file:
        print("⚠️ 未选择输出文件名，退出程序。")
        return

    toml_file = Path(toml_file)
    output_dir = Path(output_dir)
    output_file = Path(output_file).name

    if toml_file.exists():
        with open(toml_file, 'r', encoding='utf-8') as f:
            config_data = toml.load(f)
        generate_config_code(config_data, output_dir, output_file)
    else:
        print("⚠️ TOML 文件不存在，无法生成配置类。")


if __name__ == "__main__":
    watch_toml_file()
